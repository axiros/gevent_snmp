diff --git a/src/include/net-snmp/library/snmp_api.h b/src/include/net-snmp/library/snmp_api.h
index cb61ef7..e93ef6b 100644
--- a/src/include/net-snmp/library/snmp_api.h
+++ b/src/include/net-snmp/library/snmp_api.h
@@ -397,6 +397,34 @@ typedef struct request_list {
 
 #define SNMP_DETAIL_SIZE        512
 
+/* I know this is wired shit.
+ * The root cause for this: fd_set only supports 1024 sockets.
+ * To understand why this causes trouble here is bit more backround:
+ * As you know a socket is just a number (file descriptor),
+ * so when you request a socket from the kernel you get just a number back.
+ * The problem with fd_set is, it's only a bitmap. Which means for socket
+ * number 30, the bit 30 is set. For socket number 700, bit 700 is set.
+ * .... and so on.
+ * As written above fd_set only support 1024 sockets, which means the bitmap
+ * supports only sockets till number 1024.
+ * Well, what happens now if we have a socket with number 2000.
+ * (2000 sockets is nothing abnormal for a high  concurrent snmp collector).
+ * Inside snmp_api.c the following would happen: FD_SET(fdset, 2000)
+ * FD_SET is pretty stupid and just sets the bit 2000 starting from fdset.
+ * However fdset is only 1024 bits big, => FD_SET(fdset, 2000) sets bits in a
+ * memory region its not allowed to. Flipping bits in random memory regions
+ * leads to SEGFAULT.
+ *
+ * When we use gevent_snmp this fdset is NOT needed at all => the problematic
+ * calls FD_SET, FD_ISSET, FD_CLR are not required.
+ * This is what the SNMP_FLAGS_AX_IGNORE_FDSET should trigger. Its set on the
+ * session->flags and can be tested everywhere in the code.
+ *
+ * Note: In snmplib 5.7 they invented a 'large_fdset', which supports more than
+ * 1024 sockets. So when we upgrade to jessi, lets have a look again.
+ */
+
+#define SNMP_FLAGS_AX_IGNORE_FDSET 0x100000   /* See the lengthy comment above. */
 #define SNMP_FLAGS_RESP_CALLBACK   0x400      /* Additional callback on response */
 #define SNMP_FLAGS_USER_CREATED    0x200      /* USM user has been created */
 #define SNMP_FLAGS_DONT_PROBE      0x100      /* don't probe for an engineID */
diff --git a/src/snmplib/snmp_api.c b/src/snmplib/snmp_api.c
index d265915..61c7fab 100644
--- a/src/snmplib/snmp_api.c
+++ b/src/snmplib/snmp_api.c
@@ -5431,11 +5431,13 @@ _sess_read(void *sessp, fd_set * fdset)
         return 0; 
     }
 
-    if (!fdset || !(FD_ISSET(transport->sock, fdset))) {
-        DEBUGMSGTL(("sess_read", "not reading %d (fdset %p set %d)\n",
-                    transport->sock, fdset,
-                    fdset ? FD_ISSET(transport->sock, fdset) : -9));
-        return 0;
+    if (!(sp->flags & SNMP_FLAGS_AX_IGNORE_FDSET)) {
+        if (!fdset || !(FD_ISSET(transport->sock, fdset))) {
+            DEBUGMSGTL(("sess_read", "not reading %d (fdset %p set %d)\n",
+                        transport->sock, fdset,
+                        fdset ? FD_ISSET(transport->sock, fdset) : -9));
+            return 0;
+        }
     }
 
     sp->s_snmp_errno = 0;
@@ -5890,7 +5892,10 @@ snmp_sess_select_info(void *sessp,
             *numfds = (slp->transport->sock + 1);
         }
 
-        FD_SET(slp->transport->sock, fdset);
+        if (!((slp->session != NULL) & (slp->session->flags & SNMP_FLAGS_AX_IGNORE_FDSET))) {
+            FD_SET(slp->transport->sock, fdset);
+        }
+
         if (slp->internal != NULL && slp->internal->requests) {
             /*
              * Found another session with outstanding requests.  
diff --git a/src/snmplib/snmp_client.c b/src/snmplib/snmp_client.c
index 5f45f1d..aab0be2 100644
--- a/src/snmplib/snmp_client.c
+++ b/src/snmplib/snmp_client.c
@@ -1063,9 +1063,40 @@ snmp_synch_response(netsnmp_session * ss,
     return snmp_synch_response_cb(ss, pdu, response, snmp_synch_input);
 }
 
+
+static int default_select(
+        void* ctx,
+        int nfds,
+        fd_set *readfds,
+        fd_set *writefds,
+        fd_set *exceptfds,
+        struct timeval *timeout)
+{
+    return select(nfds, readfds, writefds, exceptfds, timeout);
+}
+
+
 int
-snmp_sess_synch_response(void *sessp,
-                         netsnmp_pdu *pdu, netsnmp_pdu **response)
+snmp_sess_synch_response(void *sessp, netsnmp_pdu *pdu, netsnmp_pdu **response)
+{
+    return snmp_sess_synch_response_with_select(sessp, pdu, response, default_select, NULL);
+}
+
+typedef int (*select_func)(
+        void* ctx,
+        int nfds,
+        fd_set *readfds,
+        fd_set *writefds,
+        fd_set *exceptfds,
+        struct timeval *timeout);
+
+int
+snmp_sess_synch_response_with_select(
+    void *sessp,
+    netsnmp_pdu *pdu,
+    netsnmp_pdu **response,
+    select_func call_select,
+    void* select_ctx)
 {
     netsnmp_session *ss;
     struct synch_state lstate, *state;
@@ -1099,7 +1130,7 @@ snmp_sess_synch_response(void *sessp,
         snmp_sess_select_info(sessp, &numfds, &fdset, tvp, &block);
         if (block == 1)
             tvp = NULL;         /* block without timeout */
-        count = select(numfds, &fdset, 0, 0, tvp);
+        count = call_select(select_ctx, numfds, &fdset, 0, 0, tvp);
         if (count > 0) {
             snmp_sess_read(sessp, &fdset);
         } else
